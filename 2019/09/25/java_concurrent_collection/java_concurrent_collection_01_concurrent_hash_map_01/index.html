<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java," />










<meta name="description" content="ConcurrentHashMap是在JDK1.5时，J.U.C引入的一个同步集合工具类，顾名思义，这是一个线程安全的HashMap。不同版本的ConcurrentHashMap，内部实现机制千差万别，本节所有的讨论基于JDK1.8。 ConcurrentHashMap的类继承关系并不复杂：  可以看到ConcurrentHashMap继承了AbstractMap，这是一个java.util包下的">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="J.U.C 并发集合（一）：ConcurrentHashMap基础">
<meta property="og:url" content="http://yoursite.com/2019/09/25/java_concurrent_collection/java_concurrent_collection_01_concurrent_hash_map_01/index.html">
<meta property="og:site_name" content="陈树义">
<meta property="og:description" content="ConcurrentHashMap是在JDK1.5时，J.U.C引入的一个同步集合工具类，顾名思义，这是一个线程安全的HashMap。不同版本的ConcurrentHashMap，内部实现机制千差万别，本节所有的讨论基于JDK1.8。 ConcurrentHashMap的类继承关系并不复杂：  可以看到ConcurrentHashMap继承了AbstractMap，这是一个java.util包下的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15549510919969.jpg">
<meta property="og:image" content="https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15549511018883.jpg">
<meta property="og:image" content="https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15549511204925.jpg">
<meta property="og:image" content="https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15549511532973.jpg">
<meta property="og:updated_time" content="2019-09-25T00:09:56.620Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="J.U.C 并发集合（一）：ConcurrentHashMap基础">
<meta name="twitter:description" content="ConcurrentHashMap是在JDK1.5时，J.U.C引入的一个同步集合工具类，顾名思义，这是一个线程安全的HashMap。不同版本的ConcurrentHashMap，内部实现机制千差万别，本节所有的讨论基于JDK1.8。 ConcurrentHashMap的类继承关系并不复杂：  可以看到ConcurrentHashMap继承了AbstractMap，这是一个java.util包下的">
<meta name="twitter:image" content="https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15549510919969.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/25/java_concurrent_collection/java_concurrent_collection_01_concurrent_hash_map_01/"/>





  <title>J.U.C 并发集合（一）：ConcurrentHashMap基础 | 陈树义</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-113382792-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9d1e126f4ddcdf87de1bb8dd68964127";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">陈树义</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">偶尔写写文章的宅男</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/25/java_concurrent_collection/java_concurrent_collection_01_concurrent_hash_map_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈树义">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈树义">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">J.U.C 并发集合（一）：ConcurrentHashMap基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-25T07:52:09+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/并发集合系列/" itemprop="url" rel="index">
                    <span itemprop="name">并发集合系列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/09/25/java_concurrent_collection/java_concurrent_collection_01_concurrent_hash_map_01/" class="leancloud_visitors" data-flag-title="J.U.C 并发集合（一）：ConcurrentHashMap基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>ConcurrentHashMap是在JDK1.5时，J.U.C引入的一个同步集合工具类，顾名思义，这是一个线程安全的HashMap。不同版本的ConcurrentHashMap，内部实现机制千差万别，本节所有的讨论基于JDK1.8。</p>
<p>ConcurrentHashMap的类继承关系并不复杂：</p>
<p><img src="https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15549510919969.jpg" alt=""></p>
<p>可以看到ConcurrentHashMap继承了AbstractMap，这是一个java.util包下的抽象类，提供Map接口的骨干实现，以最大限度地减少实现Map这类数据结构时所需的工作量，一般来讲，如果需要重复造轮子——自己来实现一个Map，那一般就是继承AbstractMap。</p>
<p>另外，ConcurrentHashMap实现了ConcurrentMap这个接口，ConcurrentMap是在JDK1.5时随着J.U.C包引入的，这个接口其实就是提供了一些针对Map的原子操作：</p>
<p><img src="https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15549511018883.jpg" alt=""></p>
<p>ConcurrentMap接口提供的功能：</p>
<p><img src="https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15549511204925.jpg" alt=""></p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>我们先来看下ConcurrentHashMap对象的内部结构究竟什么样的：</p>
<p><img src="https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15549511532973.jpg" alt=""></p>
<p>ConcurrentHashMap内部维护了一个Node类型的数组，也就是table：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient volatile Node&lt;K, V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p>数组的每一个位置table[i]代表了一个桶，当插入键值对时，会根据键的hash值映射到不同的桶位置，table一共可以包含4种不同类型的桶：Node、TreeBin、ForwardingNode、ReservationNode。上图中，不同的桶用不同颜色表示。可以看到，有的桶链接着链表，有的桶链接着树，这也是JDK1.8中ConcurrentHashMap的特殊之处，后面会详细讲到。</p>
<p>需要注意的是：TreeBin所链接的是一颗红黑树，红黑树的结点用TreeNode表示，所以ConcurrentHashMap中实际上一共有五种不同类型的Node结点。</p>
<p>之所以用TreeBin而不是直接用TreeNode，是因为红黑树的操作比较复杂，包括构建、左旋、右旋、删除，平衡等操作，用一个代理结点TreeBin来包含这些复杂操作，其实是一种“职责分离”的思想。另外TreeBin中也包含了一些加/解锁的操作。</p>
<p>ConcurrentHashMap一共包含5种结点，我们来看下各个结点的定义和作用。</p>
<h3 id="Node结点"><a href="#Node结点" class="headerlink" title="Node结点"></a>Node结点</h3><p>Node结点的定义非常简单，也是其它四种类型结点的父类。</p>
<blockquote>
<p>默认链接到table[i]——桶上的结点就是Node结点。<br>当出现hash冲突时，Node结点会首先以链表的形式链接到table上，当结点数量超过一定数目时，链表会转化为红黑树。因为链表查找的平均时间复杂度为O(n)，而红黑树是一种平衡二叉树，其平均时间复杂度为O(logn)。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 普通的Entry结点, 以链表形式保存时才会使用, 存储实际的数据.</span><br><span class="line"> */</span><br><span class="line">static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    volatile V val;</span><br><span class="line">    volatile Node&lt;K, V&gt; next;   // 链表指针</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V val, Node&lt;K, V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V getValue() &#123;</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return key.hashCode() ^ val.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() &#123;</span><br><span class="line">        return key + &quot;=&quot; + val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V setValue(V value) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        Object k, v, u;</span><br><span class="line">        Map.Entry&lt;?, ?&gt; e;</span><br><span class="line">        return ((o instanceof Map.Entry) &amp;&amp;</span><br><span class="line">            (k = (e = (Map.Entry&lt;?, ?&gt;) o).getKey()) != null &amp;&amp;</span><br><span class="line">            (v = e.getValue()) != null &amp;&amp;</span><br><span class="line">            (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">            (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链表查找.</span><br><span class="line">     */</span><br><span class="line">    Node&lt;K, V&gt; find(int h, Object k) &#123;</span><br><span class="line">        Node&lt;K, V&gt; e = this;</span><br><span class="line">        if (k != null) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                if (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TreeNode结点"><a href="#TreeNode结点" class="headerlink" title="TreeNode结点"></a>TreeNode结点</h3><p>TreeNode就是红黑树的结点，TreeNode不会直接链接到table[i]——桶上面，而是由TreeBin链接，TreeBin会指向红黑树的根结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 红黑树结点, 存储实际的数据.</span><br><span class="line"> */</span><br><span class="line">static final class TreeNode&lt;K, V&gt; extends Node&lt;K, V&gt; &#123;</span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K, V&gt; parent;</span><br><span class="line">    TreeNode&lt;K, V&gt; left;</span><br><span class="line">    TreeNode&lt;K, V&gt; right;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * prev指针是为了方便删除.</span><br><span class="line">     * 删除链表的非头结点时，需要知道它的前驱结点才能删除，所以直接提供一个prev指针</span><br><span class="line">     */</span><br><span class="line">    TreeNode&lt;K, V&gt; prev;</span><br><span class="line"></span><br><span class="line">    TreeNode(int hash, K key, V val, Node&lt;K, V&gt; next,</span><br><span class="line">             TreeNode&lt;K, V&gt; parent) &#123;</span><br><span class="line">        super(hash, key, val, next);</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt; find(int h, Object k) &#123;</span><br><span class="line">        return findTreeNode(h, k, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 以当前结点（this）为根结点，开始遍历查找指定key.</span><br><span class="line">     */</span><br><span class="line">    final TreeNode&lt;K, V&gt; findTreeNode(int h, Object k, Class&lt;?&gt; kc) &#123;</span><br><span class="line">        if (k != null) &#123;</span><br><span class="line">            TreeNode&lt;K, V&gt; p = this;</span><br><span class="line">            do &#123;</span><br><span class="line">                int ph, dir;</span><br><span class="line">                K pk;</span><br><span class="line">                TreeNode&lt;K, V&gt; q;</span><br><span class="line">                TreeNode&lt;K, V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                if ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if (pl == null)</span><br><span class="line">                    p = pr;</span><br><span class="line">                else if (pr == null)</span><br><span class="line">                    p = pl;</span><br><span class="line">                else if ((kc != null ||</span><br><span class="line">                    (kc = comparableClassFor(k)) != null) &amp;&amp;</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) != 0)</span><br><span class="line">                    p = (dir &lt; 0) ? pl : pr;</span><br><span class="line">                else if ((q = pr.findTreeNode(h, k, kc)) != null)</span><br><span class="line">                    return q;</span><br><span class="line">                else</span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; while (p != null);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TreeBin结点"><a href="#TreeBin结点" class="headerlink" title="TreeBin结点"></a>TreeBin结点</h3><p>TreeBin相当于TreeNode的代理结点。TreeBin会直接链接到table[i]——桶上面，该结点提供了一系列红黑树相关的操作，以及加锁、解锁操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * TreeNode的代理结点（相当于封装了TreeNode的容器，提供针对红黑树的转换操作和锁控制）</span><br><span class="line"> * hash值固定为-3</span><br><span class="line"> */</span><br><span class="line">static final class TreeBin&lt;K, V&gt; extends Node&lt;K, V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K, V&gt; root;                // 红黑树结构的根结点</span><br><span class="line">    volatile TreeNode&lt;K, V&gt; first;      // 链表结构的头结点</span><br><span class="line">    volatile Thread waiter;             // 最近的一个设置WAITER标识位的线程</span><br><span class="line"></span><br><span class="line">    volatile int lockState;             // 整体的锁状态标识位</span><br><span class="line"></span><br><span class="line">    static final int WRITER = 1;        // 二进制001，红黑树的写锁状态</span><br><span class="line">    static final int WAITER = 2;        // 二进制010，红黑树的等待获取写锁状态</span><br><span class="line">    static final int READER = 4;        // 二进制100，红黑树的读锁状态，读可以并发，每多一个读线程，lockState都加上一个READER值</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在hashCode相等并且不是Comparable类型时，用此方法判断大小.</span><br><span class="line">     */</span><br><span class="line">    static int tieBreakOrder(Object a, Object b) &#123;</span><br><span class="line">        int d;</span><br><span class="line">        if (a == null || b == null ||</span><br><span class="line">            (d = a.getClass().getName().</span><br><span class="line">                compareTo(b.getClass().getName())) == 0)</span><br><span class="line">            d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                -1 : 1);</span><br><span class="line">        return d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将以b为头结点的链表转换为红黑树.</span><br><span class="line">     */</span><br><span class="line">    TreeBin(TreeNode&lt;K, V&gt; b) &#123;</span><br><span class="line">        super(TREEBIN, null, null, null);</span><br><span class="line">        this.first = b;</span><br><span class="line">        TreeNode&lt;K, V&gt; r = null;</span><br><span class="line">        for (TreeNode&lt;K, V&gt; x = b, next; x != null; x = next) &#123;</span><br><span class="line">            next = (TreeNode&lt;K, V&gt;) x.next;</span><br><span class="line">            x.left = x.right = null;</span><br><span class="line">            if (r == null) &#123;</span><br><span class="line">                x.parent = null;</span><br><span class="line">                x.red = false;</span><br><span class="line">                r = x;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                K k = x.key;</span><br><span class="line">                int h = x.hash;</span><br><span class="line">                Class&lt;?&gt; kc = null;</span><br><span class="line">                for (TreeNode&lt;K, V&gt; p = r; ; ) &#123;</span><br><span class="line">                    int dir, ph;</span><br><span class="line">                    K pk = p.key;</span><br><span class="line">                    if ((ph = p.hash) &gt; h)</span><br><span class="line">                        dir = -1;</span><br><span class="line">                    else if (ph &lt; h)</span><br><span class="line">                        dir = 1;</span><br><span class="line">                    else if ((kc == null &amp;&amp;</span><br><span class="line">                        (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) == 0)</span><br><span class="line">                        dir = tieBreakOrder(k, pk);</span><br><span class="line">                    TreeNode&lt;K, V&gt; xp = p;</span><br><span class="line">                    if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">                        x.parent = xp;</span><br><span class="line">                        if (dir &lt;= 0)</span><br><span class="line">                            xp.left = x;</span><br><span class="line">                        else</span><br><span class="line">                            xp.right = x;</span><br><span class="line">                        r = balanceInsertion(r, x);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.root = r;</span><br><span class="line">        assert checkInvariants(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对红黑树的根结点加写锁.</span><br><span class="line">     */</span><br><span class="line">    private final void lockRoot() &#123;</span><br><span class="line">        if (!U.compareAndSwapInt(this, LOCKSTATE, 0, WRITER))</span><br><span class="line">            contendedLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放写锁.</span><br><span class="line">     */</span><br><span class="line">    private final void unlockRoot() &#123;</span><br><span class="line">        lockState = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Possibly blocks awaiting root lock.</span><br><span class="line">     */</span><br><span class="line">    private final void contendedLock() &#123;</span><br><span class="line">        boolean waiting = false;</span><br><span class="line">        for (int s; ; ) &#123;</span><br><span class="line">            if (((s = lockState) &amp; ~WAITER) == 0) &#123;</span><br><span class="line">                if (U.compareAndSwapInt(this, LOCKSTATE, s, WRITER)) &#123;</span><br><span class="line">                    if (waiting)</span><br><span class="line">                        waiter = null;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if ((s &amp; WAITER) == 0) &#123;</span><br><span class="line">                if (U.compareAndSwapInt(this, LOCKSTATE, s, s | WAITER)) &#123;</span><br><span class="line">                    waiting = true;</span><br><span class="line">                    waiter = Thread.currentThread();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (waiting)</span><br><span class="line">                LockSupport.park(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从根结点开始遍历查找，找到“相等”的结点就返回它，没找到就返回null</span><br><span class="line">     * 当存在写锁时，以链表方式进行查找</span><br><span class="line">     */</span><br><span class="line">    final Node&lt;K, V&gt; find(int h, Object k) &#123;</span><br><span class="line">        if (k != null) &#123;</span><br><span class="line">            for (Node&lt;K, V&gt; e = first; e != null; ) &#123;</span><br><span class="line">                int s;</span><br><span class="line">                K ek;</span><br><span class="line">                /**</span><br><span class="line">                 * 两种特殊情况下以链表的方式进行查找:</span><br><span class="line">                 * 1. 有线程正持有写锁，这样做能够不阻塞读线程</span><br><span class="line">                 * 2. 有线程等待获取写锁，不再继续加读锁，相当于“写优先”模式</span><br><span class="line">                 */</span><br><span class="line">                if (((s = lockState) &amp; (WAITER | WRITER)) != 0) &#123;</span><br><span class="line">                    if (e.hash == h &amp;&amp;</span><br><span class="line">                        ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                        return e;</span><br><span class="line">                    e = e.next;</span><br><span class="line">                &#125; else if (U.compareAndSwapInt(this, LOCKSTATE, s,</span><br><span class="line">                    s + READER)) &#123;</span><br><span class="line">                    TreeNode&lt;K, V&gt; r, p;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        p = ((r = root) == null ? null :</span><br><span class="line">                            r.findTreeNode(h, k, null));</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        Thread w;</span><br><span class="line">                        if (U.getAndAddInt(this, LOCKSTATE, -READER) ==</span><br><span class="line">                            (READER | WAITER) &amp;&amp; (w = waiter) != null)</span><br><span class="line">                            LockSupport.unpark(w);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查找指定key对应的结点,如果未找到，则插入.</span><br><span class="line">     *</span><br><span class="line">     * @return 插入成功返回null, 否则返回找到的结点</span><br><span class="line">     */</span><br><span class="line">    final TreeNode&lt;K, V&gt; putTreeVal(int h, K k, V v) &#123;</span><br><span class="line">        Class&lt;?&gt; kc = null;</span><br><span class="line">        boolean searched = false;</span><br><span class="line">        for (TreeNode&lt;K, V&gt; p = root; ; ) &#123;</span><br><span class="line">            int dir, ph;</span><br><span class="line">            K pk;</span><br><span class="line">            if (p == null) &#123;</span><br><span class="line">                first = root = new TreeNode&lt;K, V&gt;(h, k, v, null, null);</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if ((ph = p.hash) &gt; h)</span><br><span class="line">                dir = -1;</span><br><span class="line">            else if (ph &lt; h)</span><br><span class="line">                dir = 1;</span><br><span class="line">            else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))</span><br><span class="line">                return p;</span><br><span class="line">            else if ((kc == null &amp;&amp;</span><br><span class="line">                (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                (dir = compareComparables(kc, k, pk)) == 0) &#123;</span><br><span class="line">                if (!searched) &#123;</span><br><span class="line">                    TreeNode&lt;K, V&gt; q, ch;</span><br><span class="line">                    searched = true;</span><br><span class="line">                    if (((ch = p.left) != null &amp;&amp;</span><br><span class="line">                        (q = ch.findTreeNode(h, k, kc)) != null) ||</span><br><span class="line">                        ((ch = p.right) != null &amp;&amp;</span><br><span class="line">                            (q = ch.findTreeNode(h, k, kc)) != null))</span><br><span class="line">                        return q;</span><br><span class="line">                &#125;</span><br><span class="line">                dir = tieBreakOrder(k, pk);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K, V&gt; xp = p;</span><br><span class="line">            if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">                TreeNode&lt;K, V&gt; x, f = first;</span><br><span class="line">                first = x = new TreeNode&lt;K, V&gt;(h, k, v, f, xp);</span><br><span class="line">                if (f != null)</span><br><span class="line">                    f.prev = x;</span><br><span class="line">                if (dir &lt;= 0)</span><br><span class="line">                    xp.left = x;</span><br><span class="line">                else</span><br><span class="line">                    xp.right = x;</span><br><span class="line">                if (!xp.red)</span><br><span class="line">                    x.red = true;</span><br><span class="line">                else &#123;</span><br><span class="line">                    lockRoot();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        root = balanceInsertion(root, x);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        unlockRoot();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        assert checkInvariants(root);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除红黑树的结点：</span><br><span class="line">     * 1. 红黑树规模太小时，返回true，然后进行 树 -&gt; 链表 的转化;</span><br><span class="line">     * 2. 红黑树规模足够时，不用变换成链表，但删除结点时需要加写锁.</span><br><span class="line">     */</span><br><span class="line">    final boolean removeTreeNode(TreeNode&lt;K, V&gt; p) &#123;</span><br><span class="line">        TreeNode&lt;K, V&gt; next = (TreeNode&lt;K, V&gt;) p.next;</span><br><span class="line">        TreeNode&lt;K, V&gt; pred = p.prev;  // unlink traversal pointers</span><br><span class="line">        TreeNode&lt;K, V&gt; r, rl;</span><br><span class="line">        if (pred == null)</span><br><span class="line">            first = next;</span><br><span class="line">        else</span><br><span class="line">            pred.next = next;</span><br><span class="line">        if (next != null)</span><br><span class="line">            next.prev = pred;</span><br><span class="line">        if (first == null) &#123;</span><br><span class="line">            root = null;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((r = root) == null || r.right == null || // too small</span><br><span class="line">            (rl = r.left) == null || rl.left == null)</span><br><span class="line">            return true;</span><br><span class="line">        lockRoot();</span><br><span class="line">        try &#123;</span><br><span class="line">            TreeNode&lt;K, V&gt; replacement;</span><br><span class="line">            TreeNode&lt;K, V&gt; pl = p.left;</span><br><span class="line">            TreeNode&lt;K, V&gt; pr = p.right;</span><br><span class="line">            if (pl != null &amp;&amp; pr != null) &#123;</span><br><span class="line">                TreeNode&lt;K, V&gt; s = pr, sl;</span><br><span class="line">                while ((sl = s.left) != null) // find successor</span><br><span class="line">                    s = sl;</span><br><span class="line">                boolean c = s.red;</span><br><span class="line">                s.red = p.red;</span><br><span class="line">                p.red = c; // swap colors</span><br><span class="line">                TreeNode&lt;K, V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K, V&gt; pp = p.parent;</span><br><span class="line">                if (s == pr) &#123; // p was s&apos;s direct parent</span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    TreeNode&lt;K, V&gt; sp = s.parent;</span><br><span class="line">                    if ((p.parent = sp) != null) &#123;</span><br><span class="line">                        if (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        else</span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if ((s.right = pr) != null)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">                p.left = null;</span><br><span class="line">                if ((p.right = sr) != null)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">                if ((s.left = pl) != null)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">                if ((s.parent = pp) == null)</span><br><span class="line">                    r = s;</span><br><span class="line">                else if (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                else</span><br><span class="line">                    pp.right = s;</span><br><span class="line">                if (sr != null)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                else</span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125; else if (pl != null)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            else if (pr != null)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            else</span><br><span class="line">                replacement = p;</span><br><span class="line">            if (replacement != p) &#123;</span><br><span class="line">                TreeNode&lt;K, V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                if (pp == null)</span><br><span class="line">                    r = replacement;</span><br><span class="line">                else if (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                else</span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root = (p.red) ? r : balanceDeletion(r, replacement);</span><br><span class="line"></span><br><span class="line">            if (p == replacement) &#123;  // detach pointers</span><br><span class="line">                TreeNode&lt;K, V&gt; pp;</span><br><span class="line">                if ((pp = p.parent) != null) &#123;</span><br><span class="line">                    if (p == pp.left)</span><br><span class="line">                        pp.left = null;</span><br><span class="line">                    else if (p == pp.right)</span><br><span class="line">                        pp.right = null;</span><br><span class="line">                    p.parent = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            unlockRoot();</span><br><span class="line">        &#125;</span><br><span class="line">        assert checkInvariants(root);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以下是红黑树的经典操作方法，改编自《算法导论》</span><br><span class="line">    static &lt;K, V&gt; TreeNode&lt;K, V&gt; rotateLeft(TreeNode&lt;K, V&gt; root,</span><br><span class="line">                                            TreeNode&lt;K, V&gt; p) &#123;</span><br><span class="line">        TreeNode&lt;K, V&gt; r, pp, rl;</span><br><span class="line">        if (p != null &amp;&amp; (r = p.right) != null) &#123;</span><br><span class="line">            if ((rl = p.right = r.left) != null)</span><br><span class="line">                rl.parent = p;</span><br><span class="line">            if ((pp = r.parent = p.parent) == null)</span><br><span class="line">                (root = r).red = false;</span><br><span class="line">            else if (pp.left == p)</span><br><span class="line">                pp.left = r;</span><br><span class="line">            else</span><br><span class="line">                pp.right = r;</span><br><span class="line">            r.left = p;</span><br><span class="line">            p.parent = r;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;K, V&gt; TreeNode&lt;K, V&gt; rotateRight(TreeNode&lt;K, V&gt; root,</span><br><span class="line">                                             TreeNode&lt;K, V&gt; p) &#123;</span><br><span class="line">        TreeNode&lt;K, V&gt; l, pp, lr;</span><br><span class="line">        if (p != null &amp;&amp; (l = p.left) != null) &#123;</span><br><span class="line">            if ((lr = p.left = l.right) != null)</span><br><span class="line">                lr.parent = p;</span><br><span class="line">            if ((pp = l.parent = p.parent) == null)</span><br><span class="line">                (root = l).red = false;</span><br><span class="line">            else if (pp.right == p)</span><br><span class="line">                pp.right = l;</span><br><span class="line">            else</span><br><span class="line">                pp.left = l;</span><br><span class="line">            l.right = p;</span><br><span class="line">            p.parent = l;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;K, V&gt; TreeNode&lt;K, V&gt; balanceInsertion(TreeNode&lt;K, V&gt; root,</span><br><span class="line">                                                  TreeNode&lt;K, V&gt; x) &#123;</span><br><span class="line">        x.red = true;</span><br><span class="line">        for (TreeNode&lt;K, V&gt; xp, xpp, xppl, xppr; ; ) &#123;</span><br><span class="line">            if ((xp = x.parent) == null) &#123;</span><br><span class="line">                x.red = false;</span><br><span class="line">                return x;</span><br><span class="line">            &#125; else if (!xp.red || (xpp = xp.parent) == null)</span><br><span class="line">                return root;</span><br><span class="line">            if (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123;</span><br><span class="line">                    xppr.red = false;</span><br><span class="line">                    xp.red = false;</span><br><span class="line">                    xpp.red = true;</span><br><span class="line">                    x = xpp;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (x == xp.right) &#123;</span><br><span class="line">                        root = rotateLeft(root, x = xp);</span><br><span class="line">                        xpp = (xp = x.parent) == null ? null : xp.parent;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xp != null) &#123;</span><br><span class="line">                        xp.red = false;</span><br><span class="line">                        if (xpp != null) &#123;</span><br><span class="line">                            xpp.red = true;</span><br><span class="line">                            root = rotateRight(root, xpp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (xppl != null &amp;&amp; xppl.red) &#123;</span><br><span class="line">                    xppl.red = false;</span><br><span class="line">                    xp.red = false;</span><br><span class="line">                    xpp.red = true;</span><br><span class="line">                    x = xpp;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (x == xp.left) &#123;</span><br><span class="line">                        root = rotateRight(root, x = xp);</span><br><span class="line">                        xpp = (xp = x.parent) == null ? null : xp.parent;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xp != null) &#123;</span><br><span class="line">                        xp.red = false;</span><br><span class="line">                        if (xpp != null) &#123;</span><br><span class="line">                            xpp.red = true;</span><br><span class="line">                            root = rotateLeft(root, xpp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;K, V&gt; TreeNode&lt;K, V&gt; balanceDeletion(TreeNode&lt;K, V&gt; root,</span><br><span class="line">                                                 TreeNode&lt;K, V&gt; x) &#123;</span><br><span class="line">        for (TreeNode&lt;K, V&gt; xp, xpl, xpr; ; ) &#123;</span><br><span class="line">            if (x == null || x == root)</span><br><span class="line">                return root;</span><br><span class="line">            else if ((xp = x.parent) == null) &#123;</span><br><span class="line">                x.red = false;</span><br><span class="line">                return x;</span><br><span class="line">            &#125; else if (x.red) &#123;</span><br><span class="line">                x.red = false;</span><br><span class="line">                return root;</span><br><span class="line">            &#125; else if ((xpl = xp.left) == x) &#123;</span><br><span class="line">                if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123;</span><br><span class="line">                    xpr.red = false;</span><br><span class="line">                    xp.red = true;</span><br><span class="line">                    root = rotateLeft(root, xp);</span><br><span class="line">                    xpr = (xp = x.parent) == null ? null : xp.right;</span><br><span class="line">                &#125;</span><br><span class="line">                if (xpr == null)</span><br><span class="line">                    x = xp;</span><br><span class="line">                else &#123;</span><br><span class="line">                    TreeNode&lt;K, V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                    if ((sr == null || !sr.red) &amp;&amp;</span><br><span class="line">                        (sl == null || !sl.red)) &#123;</span><br><span class="line">                        xpr.red = true;</span><br><span class="line">                        x = xp;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (sr == null || !sr.red) &#123;</span><br><span class="line">                            if (sl != null)</span><br><span class="line">                                sl.red = false;</span><br><span class="line">                            xpr.red = true;</span><br><span class="line">                            root = rotateRight(root, xpr);</span><br><span class="line">                            xpr = (xp = x.parent) == null ?</span><br><span class="line">                                null : xp.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (xpr != null) &#123;</span><br><span class="line">                            xpr.red = (xp == null) ? false : xp.red;</span><br><span class="line">                            if ((sr = xpr.right) != null)</span><br><span class="line">                                sr.red = false;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (xp != null) &#123;</span><br><span class="line">                            xp.red = false;</span><br><span class="line">                            root = rotateLeft(root, xp);</span><br><span class="line">                        &#125;</span><br><span class="line">                        x = root;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; // symmetric</span><br><span class="line">                if (xpl != null &amp;&amp; xpl.red) &#123;</span><br><span class="line">                    xpl.red = false;</span><br><span class="line">                    xp.red = true;</span><br><span class="line">                    root = rotateRight(root, xp);</span><br><span class="line">                    xpl = (xp = x.parent) == null ? null : xp.left;</span><br><span class="line">                &#125;</span><br><span class="line">                if (xpl == null)</span><br><span class="line">                    x = xp;</span><br><span class="line">                else &#123;</span><br><span class="line">                    TreeNode&lt;K, V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                    if ((sl == null || !sl.red) &amp;&amp;</span><br><span class="line">                        (sr == null || !sr.red)) &#123;</span><br><span class="line">                        xpl.red = true;</span><br><span class="line">                        x = xp;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (sl == null || !sl.red) &#123;</span><br><span class="line">                            if (sr != null)</span><br><span class="line">                                sr.red = false;</span><br><span class="line">                            xpl.red = true;</span><br><span class="line">                            root = rotateLeft(root, xpl);</span><br><span class="line">                            xpl = (xp = x.parent) == null ?</span><br><span class="line">                                null : xp.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (xpl != null) &#123;</span><br><span class="line">                            xpl.red = (xp == null) ? false : xp.red;</span><br><span class="line">                            if ((sl = xpl.left) != null)</span><br><span class="line">                                sl.red = false;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (xp != null) &#123;</span><br><span class="line">                            xp.red = false;</span><br><span class="line">                            root = rotateRight(root, xp);</span><br><span class="line">                        &#125;</span><br><span class="line">                        x = root;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 递归检查红黑树的正确性</span><br><span class="line">     */</span><br><span class="line">    static &lt;K, V&gt; boolean checkInvariants(TreeNode&lt;K, V&gt; t) &#123;</span><br><span class="line">        TreeNode&lt;K, V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">            tb = t.prev, tn = (TreeNode&lt;K, V&gt;) t.next;</span><br><span class="line">        if (tb != null &amp;&amp; tb.next != t)</span><br><span class="line">            return false;</span><br><span class="line">        if (tn != null &amp;&amp; tn.prev != t)</span><br><span class="line">            return false;</span><br><span class="line">        if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">            return false;</span><br><span class="line">        if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">            return false;</span><br><span class="line">        if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">            return false;</span><br><span class="line">        if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red)</span><br><span class="line">            return false;</span><br><span class="line">        if (tl != null &amp;&amp; !checkInvariants(tl))</span><br><span class="line">            return false;</span><br><span class="line">        if (tr != null &amp;&amp; !checkInvariants(tr))</span><br><span class="line">            return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final sun.misc.Unsafe U;</span><br><span class="line">    private static final long LOCKSTATE;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = TreeBin.class;</span><br><span class="line">            LOCKSTATE = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;lockState&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ForwardingNode结点"><a href="#ForwardingNode结点" class="headerlink" title="ForwardingNode结点"></a>ForwardingNode结点</h3><p>ForwardingNode结点仅仅在扩容时才会使用——关于扩容，会在下一篇文章专门论述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ForwardingNode是一种临时结点，在扩容进行中才会出现，hash值固定为-1，且不存储实际数据。</span><br><span class="line"> * 如果旧table数组的一个hash桶中全部的结点都迁移到了新table中，则在这个桶中放置一个ForwardingNode。</span><br><span class="line"> * 读操作碰到ForwardingNode时，将操作转发到扩容后的新table数组上去执行；写操作碰见它时，则尝试帮助扩容。</span><br><span class="line"> */</span><br><span class="line">static final class ForwardingNode&lt;K, V&gt; extends Node&lt;K, V&gt; &#123;</span><br><span class="line">    final Node&lt;K, V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    ForwardingNode(Node&lt;K, V&gt;[] tab) &#123;</span><br><span class="line">        super(MOVED, null, null, null);</span><br><span class="line">        this.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在新的数组nextTable上进行查找</span><br><span class="line">    Node&lt;K, V&gt; find(int h, Object k) &#123;</span><br><span class="line">        // loop to avoid arbitrarily deep recursion on forwarding nodes</span><br><span class="line">        outer:</span><br><span class="line">        for (Node&lt;K, V&gt;[] tab = nextTable; ; ) &#123;</span><br><span class="line">            Node&lt;K, V&gt; e;</span><br><span class="line">            int n;</span><br><span class="line">            if (k == null || tab == null || (n = tab.length) == 0 ||</span><br><span class="line">                (e = tabAt(tab, (n - 1) &amp; h)) == null)</span><br><span class="line">                return null;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int eh;</span><br><span class="line">                K ek;</span><br><span class="line">                if ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                    return e;</span><br><span class="line">                if (eh &lt; 0) &#123;</span><br><span class="line">                    if (e instanceof ForwardingNode) &#123;</span><br><span class="line">                        tab = ((ForwardingNode&lt;K, V&gt;) e).nextTable;</span><br><span class="line">                        continue outer;</span><br><span class="line">                    &#125; else</span><br><span class="line">                        return e.find(h, k);</span><br><span class="line">                &#125;</span><br><span class="line">                if ((e = e.next) == null)</span><br><span class="line">                    return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReservationNode结点"><a href="#ReservationNode结点" class="headerlink" title="ReservationNode结点"></a>ReservationNode结点</h3><p>保留结点，ConcurrentHashMap中的一些特殊方法会专门用到该类结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 保留结点.</span><br><span class="line"> * hash值固定为-3， 不保存实际数据</span><br><span class="line"> * 只在computeIfAbsent和compute这两个函数式API中充当占位符加锁使用</span><br><span class="line"> */</span><br><span class="line">static final class ReservationNode&lt;K, V&gt; extends Node&lt;K, V&gt; &#123;</span><br><span class="line">    ReservationNode() &#123;</span><br><span class="line">        super(RESERVED, null, null, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt; find(int h, Object k) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类变量定义"><a href="#类变量定义" class="headerlink" title="类变量定义"></a>类变量定义</h2><p>我们再看下ConcurrentHashMap内部定义了哪些常量/字段，先大致熟悉下这些常量/字段，后面结合具体的方法分析就能相对容易地理解这些常量/字段的含义了。</p>
<p><strong>常量：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 最大容量.</span><br><span class="line"> */</span><br><span class="line">private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 默认初始容量</span><br><span class="line"> */</span><br><span class="line">private static final int DEFAULT_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The largest possible (non-power of two) array size.</span><br><span class="line"> * Needed by toArray and related methods.</span><br><span class="line"> */</span><br><span class="line">static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 负载因子，为了兼容JDK1.8以前的版本而保留。</span><br><span class="line"> * JDK1.8中的ConcurrentHashMap的负载因子恒定为0.75</span><br><span class="line"> */</span><br><span class="line">private static final float LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 链表转树的阈值，即链接结点数大于8时， 链表转换为树.</span><br><span class="line"> */</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 树转链表的阈值，即树结点树小于6时，树转换为链表.</span><br><span class="line"> */</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在链表转变成树之前，还会有一次判断：</span><br><span class="line"> * 即只有键值对数量大于MIN_TREEIFY_CAPACITY，才会发生转换。</span><br><span class="line"> * 这是为了避免在Table建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span><br><span class="line"> */</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在树转变成链表之前，还会有一次判断：</span><br><span class="line"> * 即只有键值对数量小于MIN_TRANSFER_STRIDE，才会发生转换.</span><br><span class="line"> */</span><br><span class="line">private static final int MIN_TRANSFER_STRIDE = 16;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用于在扩容时生成唯一的随机数.</span><br><span class="line"> */</span><br><span class="line">private static int RESIZE_STAMP_BITS = 16;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 可同时进行扩容操作的最大线程数.</span><br><span class="line"> */</span><br><span class="line">private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The bit shift for recording size stamp in sizeCtl.</span><br><span class="line"> */</span><br><span class="line">private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line">static final int MOVED = -1;                // 标识ForwardingNode结点（在扩容时才会出现，不存储实际数据）</span><br><span class="line">static final int TREEBIN = -2;              // 标识红黑树的根结点</span><br><span class="line">static final int RESERVED = -3;             // 标识ReservationNode结点（）</span><br><span class="line">static final int HASH_BITS = 0x7fffffff;    // usable bits of normal node hash</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * CPU核心数，扩容时使用</span><br><span class="line"> */</span><br><span class="line">static final int NCPU = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>
<p><strong>字段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Node数组，标识整个Map，首次插入元素时创建，大小总是2的幂次.</span><br><span class="line"> */</span><br><span class="line">transient volatile Node&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 扩容后的新Node数组，只有在扩容时才非空.</span><br><span class="line"> */</span><br><span class="line">private transient volatile Node&lt;K, V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 控制table的初始化和扩容.</span><br><span class="line"> * 0  : 初始默认值</span><br><span class="line"> * -1 : 有线程正在进行table的初始化</span><br><span class="line"> * &gt;0 : table初始化时使用的容量，或初始化/扩容完成后的threshold</span><br><span class="line"> * -(1 + nThreads) : 记录正在执行扩容任务的线程数</span><br><span class="line"> */</span><br><span class="line">private transient volatile int sizeCtl;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 扩容时需要用到的一个下标变量.</span><br><span class="line"> */</span><br><span class="line">private transient volatile int transferIndex;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计数基值,当没有线程竞争时，计数将加到该变量上。类似于LongAdder的base变量</span><br><span class="line"> */</span><br><span class="line">private transient volatile long baseCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计数数组，出现并发冲突时使用。类似于LongAdder的cells数组</span><br><span class="line"> */</span><br><span class="line">private transient volatile CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自旋标识位，用于CounterCell[]扩容时使用。类似于LongAdder的cellsBusy变量</span><br><span class="line"> */</span><br><span class="line">private transient volatile int cellsBusy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 视图相关字段</span><br><span class="line">private transient KeySetView&lt;K, V&gt; keySet;</span><br><span class="line">private transient ValuesView&lt;K, V&gt; values;</span><br><span class="line">private transient EntrySetView&lt;K, V&gt; entrySet;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>ConcurrentHashMap提供了五个构造器，这五个构造器内部最多也只是计算了下table的初始容量大小，并没有进行实际的创建table数组的工作：</p>
<blockquote>
<p>ConcurrentHashMap，采用了一种“懒加载”的模式，只有到首次插入键值对的时候，才会真正的去初始化table数组。</p>
</blockquote>
<p><strong>空构造器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>指定table初始容量的构造器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指定table初始容量的构造器.</span><br><span class="line"> * tableSizeFor会返回大于入参（initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1）的最小2次幂值</span><br><span class="line"> */</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</span><br><span class="line"></span><br><span class="line">    this.sizeCtl = cap;  //计算后的容量大小存入sizeCtl中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>根据已有的Map构造</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据已有的Map构造ConcurrentHashMap.</span><br><span class="line"> */</span><br><span class="line">public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>指定table初始容量和负载因子的构造器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指定table初始容量和负载因子的构造器.</span><br><span class="line"> */</span><br><span class="line">public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    this(initialCapacity, loadFactor, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>指定table初始容量、负载因子、并发级别的构造器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 指定table初始容量、负载因子、并发级别的构造器.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 注意：concurrencyLevel只是为了兼容JDK1.8以前的版本，并不是实际的并发级别，loadFactor也不是实际的负载因子</span><br><span class="line"> * 这两个都失去了原有的意义，仅仅对初始容量有一定的控制作用</span><br><span class="line"> */</span><br><span class="line">public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    if (initialCapacity &lt; concurrencyLevel)</span><br><span class="line">        initialCapacity = concurrencyLevel;</span><br><span class="line"></span><br><span class="line">    long size = (long) (1.0 + (long) initialCapacity / loadFactor);</span><br><span class="line">    int cap = (size &gt;= (long) MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((int) size);</span><br><span class="line">    this.sizeCtl = cap;     //计算后的容量大小存入sizeCtl中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>我们来看下ConcurrentHashMap如何插入一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入键值对，&lt;K,V&gt;均不能为null.</span><br><span class="line"> */</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put方法内部调用了putVal这个私有方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实际的插入操作</span><br><span class="line"> *</span><br><span class="line"> * @param onlyIfAbsent true:仅当key不存在时,才插入</span><br><span class="line"> */</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">    int hash = spread(key.hashCode());  // 再次计算hash值</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用链表保存时，binCount记录table[i]这个桶中所保存的结点数；</span><br><span class="line">     * 使用红黑树保存时，binCount==2，保证put后更改计数值时能够进行扩容检查，同时不触发红黑树化操作</span><br><span class="line">     */</span><br><span class="line">    int binCount = 0;</span><br><span class="line"></span><br><span class="line">    for (Node&lt;K, V&gt;[] tab = table; ; ) &#123;            // 自旋插入结点，直到成功</span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        int n, i, fh;</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)                   // CASE1: 首次初始化table —— 懒加载</span><br><span class="line">            tab = initTable();</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;    // CASE2: table[i]对应的桶为null</span><br><span class="line">            // 注意下上面table[i]的索引i的计算方式：[ key的hash值 &amp; (table.length-1) ]</span><br><span class="line">            // 这也是table容量必须为2的幂次的原因，读者可以自己看下当table.length为2的幂次时，(table.length-1)的二进制形式的特点 —— 全是1</span><br><span class="line">            // 配合这种索引计算方式可以实现key的均匀分布，减少hash冲突</span><br><span class="line">            if (casTabAt(tab, i, null, new Node&lt;K, V&gt;(hash, key, value, null))) // 插入一个链表结点</span><br><span class="line">                break;</span><br><span class="line">        &#125; else if ((fh = f.hash) == MOVED)                          // CASE3: 发现ForwardingNode结点，说明此时table正在扩容，则尝试协助数据迁移</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else &#123;                                                      // CASE4: 出现hash冲突,也就是table[i]桶中已经有了结点</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            synchronized (f) &#123;              // 锁住table[i]结点</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;   // 再判断一下table[i]是不是第一个结点, 防止其它线程的写修改</span><br><span class="line">                    if (fh &gt;= 0) &#123;          // CASE4.1: table[i]是链表结点</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        for (Node&lt;K, V&gt; e = f; ; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            // 找到“相等”的结点，判断是否需要更新value值</span><br><span class="line">                            if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K, V&gt; pred = e;</span><br><span class="line">                            if ((e = e.next) == null) &#123;     // “尾插法”插入新结点</span><br><span class="line">                                pred.next = new Node&lt;K, V&gt;(hash, key,</span><br><span class="line">                                    value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else if (f instanceof TreeBin) &#123;  // CASE4.2: table[i]是红黑树结点</span><br><span class="line">                        Node&lt;K, V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        if ((p = ((TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key, value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);     // 链表 -&gt; 红黑树 转换</span><br><span class="line">                if (oldVal != null)         // 表明本次put操作只是替换了旧值，不用更改计数值</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(1L, binCount);             // 计数值加1</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>putVal方法一共处理四种情况：</p>
<h3 id="首次初始化table-——-懒加载"><a href="#首次初始化table-——-懒加载" class="headerlink" title="首次初始化table —— 懒加载"></a>首次初始化table —— 懒加载</h3><p>之前讲构造器的时候说了，ConcurrentHashMap在构造的时候并不会初始化table数组，首次初始化就在这里通过initTable方法完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 初始化table, 使用sizeCtl作为初始化容量.</span><br><span class="line"> */</span><br><span class="line">private final Node&lt;K, V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    int sc;</span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;  //自旋直到初始化成功</span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)         // sizeCtl&lt;0 说明table已经正在初始化/扩容</span><br><span class="line">            Thread.yield();</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;  // 将sizeCtl更新成-1,表示正在初始化中</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) new Node&lt;?, ?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);     // n - (n &gt;&gt;&gt; 2) = n - n/4 = 0.75n, 前面说了loadFactor已在JDK1.8废弃</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = sc;               // 设置threshold = 0.75 * table.length</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initTable方法就是将sizeCtl字段的值（ConcurrentHashMap对象在构造时设置）作为table的大小。<br>需要注意的是这里的n - (n &gt;&gt;&gt; 2)，其实就是0.75 <em> n，sizeCtl 的值最终需要变更为0.75 </em> n，相当于设置了threshold。</p>
<h3 id="table-i-对应的桶为空"><a href="#table-i-对应的桶为空" class="headerlink" title="table[i]对应的桶为空"></a>table[i]对应的桶为空</h3><p>最简单的情况，直接CAS操作占用桶table[i]即可。</p>
<h3 id="发现ForwardingNode结点，说明正在扩容"><a href="#发现ForwardingNode结点，说明正在扩容" class="headerlink" title="发现ForwardingNode结点，说明正在扩容"></a>发现ForwardingNode结点，说明正在扩容</h3><p>说明此时table正在扩容，则尝试协助进行数据迁移。ForwardingNode结点是ConcurrentHashMap中的五类结点之一，相当于一个占位结点，表示当前table正在进行扩容，当前线程可以尝试协助数据迁移。</p>
<blockquote>
<p>扩容和数据迁移是ConcurrentHashMap中最复杂的部分，我们会在下一章专门讨论。</p>
</blockquote>
<h3 id="出现hash冲突-也就是table-i-桶中已经有了结点"><a href="#出现hash冲突-也就是table-i-桶中已经有了结点" class="headerlink" title="出现hash冲突,也就是table[i]桶中已经有了结点"></a>出现hash冲突,也就是table[i]桶中已经有了结点</h3><p>当两个不同key映射到同一个table[i]桶中时，就会出现这种情况：</p>
<ul>
<li>当table[i]的结点类型为Node——链表结点时，就会将新结点以“尾插法”的形式插入链表的尾部。</li>
<li>当table[i]的结点类型为TreeBin——红黑树代理结点时，就会将新结点通过红黑树的插入方式插入。</li>
</ul>
<p>putVal方法的最后，涉及将链表转换为红黑树 —— treeifyBin ，但实际情况并非立即就会转换，当table的容量小于64时，出于性能考虑，只是对table数组扩容1倍——tryPresize：</p>
<blockquote>
<p>tryPresize方法涉及扩容和数据迁移，我们会在下一章专门讨论。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 尝试进行 链表 -&gt; 红黑树 的转换.</span><br><span class="line"> */</span><br><span class="line">private final void treeifyBin(Node&lt;K, V&gt;[] tab, int index) &#123;</span><br><span class="line">    Node&lt;K, V&gt; b;</span><br><span class="line">    int n, sc;</span><br><span class="line">    if (tab != null) &#123;</span><br><span class="line"></span><br><span class="line">        // CASE 1: table的容量 &lt; MIN_TREEIFY_CAPACITY(64)时，直接进行table扩容，不进行红黑树转换</span><br><span class="line">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; 1);</span><br><span class="line"></span><br><span class="line">            // CASE 2: table的容量 ≥ MIN_TREEIFY_CAPACITY(64)时，进行链表 -&gt; 红黑树的转换</span><br><span class="line">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;</span><br><span class="line">            synchronized (b) &#123;</span><br><span class="line">                if (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K, V&gt; hd = null, tl = null;</span><br><span class="line"></span><br><span class="line">                    // 遍历链表，建立红黑树</span><br><span class="line">                    for (Node&lt;K, V&gt; e = b; e != null; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K, V&gt; p = new TreeNode&lt;K, V&gt;(e.hash, e.key, e.val, null, null);</span><br><span class="line">                        if ((p.prev = tl) == null)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        else</span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 以TreeBin类型包装，并链接到table[index]中</span><br><span class="line">                    setTabAt(tab, index, new TreeBin&lt;K, V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><p>我们来看下ConcurrentHashMap如何根据key来查找一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据key查找对应的value值</span><br><span class="line"> *</span><br><span class="line"> * @return 查找不到则返回null</span><br><span class="line"> * @throws NullPointerException if the specified key is null</span><br><span class="line"> */</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; e, p;</span><br><span class="line">    int n, eh;</span><br><span class="line">    K ek;</span><br><span class="line">    int h = spread(key.hashCode());     // 重新计算key的hash值</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        if ((eh = e.hash) == h) &#123;       // table[i]就是待查找的项，直接返回</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125; else if (eh &lt; 0)              // hash值&lt;0, 说明遇到特殊结点(非链表结点), 调用find方法查找</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">        while ((e = e.next) != null) &#123;  // 按链表方式查找</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法的逻辑很简单，首先根据key的hash值计算映射到table的哪个桶——table[i]。</p>
<ol>
<li>如果table[i]的key和待查找key相同，那直接返回；</li>
<li>如果table[i]对应的结点是特殊结点（hash值小于0），则通过find方法查找；</li>
<li>如果table[i]对应的结点是普通链表结点，则按链表方式查找。</li>
</ol>
<p>关键是第二种情况，不同结点的find查找方式有所不同，我们来具体看下：</p>
<h3 id="Node结点的查找"><a href="#Node结点的查找" class="headerlink" title="Node结点的查找"></a>Node结点的查找</h3><p>当槽table[i]被普通Node结点占用，说明是链表链接的形式，直接从链表头开始查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表查找.</span><br><span class="line"> */</span><br><span class="line">Node&lt;K, V&gt; find(int h, Object k) &#123;</span><br><span class="line">    Node&lt;K, V&gt; e = this;</span><br><span class="line">    if (k != null) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            K ek;</span><br><span class="line">            if (e.hash == h &amp;&amp; ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                return e;</span><br><span class="line">        &#125; while ((e = e.next) != null);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TreeBin结点的查找"><a href="#TreeBin结点的查找" class="headerlink" title="TreeBin结点的查找"></a>TreeBin结点的查找</h3><p>TreeBin的查找比较特殊，我们知道当槽table[i]被TreeBin结点占用时，说明链接的是一棵红黑树。由于红黑树的插入、删除会涉及整个结构的调整，所以通常存在读写并发操作的时候，是需要加锁的。</p>
<blockquote>
<p>ConcurrentHashMap采用了一种类似读写锁的方式：当线程持有写锁（修改红黑树）时，如果读线程需要查找，不会像传统的读写锁那样阻塞等待，而是转而以链表的形式进行查找（TreeBin本身时Node类型的子类，所有拥有Node的所有字段）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从根结点开始遍历查找，找到“相等”的结点就返回它，没找到就返回null</span><br><span class="line"> * 当存在写锁时，以链表方式进行查找</span><br><span class="line"> */</span><br><span class="line">final Node&lt;K, V&gt; find(int h, Object k) &#123;</span><br><span class="line">    if (k != null) &#123;</span><br><span class="line">        for (Node&lt;K, V&gt; e = first; e != null; ) &#123;</span><br><span class="line">            int s;</span><br><span class="line">            K ek;</span><br><span class="line">            /**</span><br><span class="line">             * 两种特殊情况下以链表的方式进行查找:</span><br><span class="line">             * 1. 有线程正持有写锁，这样做能够不阻塞读线程</span><br><span class="line">             * 2. 有线程等待获取写锁，不再继续加读锁，相当于“写优先”模式</span><br><span class="line">             */</span><br><span class="line">            if (((s = lockState) &amp; (WAITER | WRITER)) != 0) &#123;</span><br><span class="line">                if (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                    return e;</span><br><span class="line">                e = e.next;     // 链表形式</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 读线程数量加1，读状态进行累加</span><br><span class="line">            else if (U.compareAndSwapInt(this, LOCKSTATE, s, s + READER)) &#123;</span><br><span class="line">                TreeNode&lt;K, V&gt; r, p;</span><br><span class="line">                try &#123;</span><br><span class="line">                    p = ((r = root) == null ? null :</span><br><span class="line">                        r.findTreeNode(h, k, null));</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    Thread w;</span><br><span class="line">                    // 如果当前线程是最后一个读线程，且有写线程因为读锁而阻塞，则写线程，告诉它可以尝试获取写锁了</span><br><span class="line">                    if (U.getAndAddInt(this, LOCKSTATE, -READER) == (READER | WAITER) &amp;&amp; (w = waiter) != null)</span><br><span class="line">                        LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ForwardingNode结点的查找"><a href="#ForwardingNode结点的查找" class="headerlink" title="ForwardingNode结点的查找"></a>ForwardingNode结点的查找</h3><p>ForwardingNode是一种临时结点，在扩容进行中才会出现，所以查找也在扩容的table上进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在新的扩容table——nextTable上进行查找</span><br><span class="line"> */</span><br><span class="line">Node&lt;K, V&gt; find(int h, Object k) &#123;</span><br><span class="line">    // loop to avoid arbitrarily deep recursion on forwarding nodes</span><br><span class="line">    outer:</span><br><span class="line">    for (Node&lt;K, V&gt;[] tab = nextTable; ; ) &#123;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        int n;</span><br><span class="line">        if (k == null || tab == null || (n = tab.length) == 0 ||</span><br><span class="line">            (e = tabAt(tab, (n - 1) &amp; h)) == null)</span><br><span class="line">            return null;</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            int eh;</span><br><span class="line">            K ek;</span><br><span class="line">            if ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                return e;</span><br><span class="line">            if (eh &lt; 0) &#123;</span><br><span class="line">                if (e instanceof ForwardingNode) &#123;</span><br><span class="line">                    tab = ((ForwardingNode&lt;K, V&gt;) e).nextTable;</span><br><span class="line">                    continue outer;</span><br><span class="line">                &#125; else</span><br><span class="line">                    return e.find(h, k);</span><br><span class="line">            &#125;</span><br><span class="line">            if ((e = e.next) == null)</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReservationNode结点的查找"><a href="#ReservationNode结点的查找" class="headerlink" title="ReservationNode结点的查找"></a>ReservationNode结点的查找</h3><p>ReservationNode是保留结点，不保存实际数据，所以直接返回null：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K, V&gt; find(int h, Object k) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文较为详细地分析了ConcurrentHashMap的内部结构和典型方法的实现，下一篇将分析ConcurrentHashMap最复杂的部分——扩容/数据转移。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/25/java_blocking_queue/java_blocking_queue_09_summary/" rel="next" title="J.U.C 阻塞队列（九）：总结">
                <i class="fa fa-chevron-left"></i> J.U.C 阻塞队列（九）：总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/25/java_concurrent_collection/java_concurrent_collection_02_concurrent_hash_map_02/" rel="prev" title="J.U.C 并发集合（二）：ConcurrentHashMap 扩容">
                J.U.C 并发集合（二）：ConcurrentHashMap 扩容 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">陈树义</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">137</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenyurong" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:shuyi.chen.china@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/chen-shu-yi-21/activities" target="_blank" title="ZhiHu">
                      
                        <i class="fa fa-fw fa-book"></i>ZhiHu</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://dancefirstthinklater.github.io/" title="Java源码爱好者-草草集" target="_blank">Java源码爱好者-草草集</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://jm.taobao.org/" title="阿里巴巴中间件团队博客" target="_blank">阿里巴巴中间件团队博客</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本结构"><span class="nav-number">1.</span> <span class="nav-text">基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Node结点"><span class="nav-number">1.1.</span> <span class="nav-text">Node结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeNode结点"><span class="nav-number">1.2.</span> <span class="nav-text">TreeNode结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeBin结点"><span class="nav-number">1.3.</span> <span class="nav-text">TreeBin结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForwardingNode结点"><span class="nav-number">1.4.</span> <span class="nav-text">ForwardingNode结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReservationNode结点"><span class="nav-number">1.5.</span> <span class="nav-text">ReservationNode结点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类变量定义"><span class="nav-number">2.</span> <span class="nav-text">类变量定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造方法"><span class="nav-number">3.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#put操作"><span class="nav-number">4.</span> <span class="nav-text">put操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#首次初始化table-——-懒加载"><span class="nav-number">4.1.</span> <span class="nav-text">首次初始化table —— 懒加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#table-i-对应的桶为空"><span class="nav-number">4.2.</span> <span class="nav-text">table[i]对应的桶为空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发现ForwardingNode结点，说明正在扩容"><span class="nav-number">4.3.</span> <span class="nav-text">发现ForwardingNode结点，说明正在扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#出现hash冲突-也就是table-i-桶中已经有了结点"><span class="nav-number">4.4.</span> <span class="nav-text">出现hash冲突,也就是table[i]桶中已经有了结点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get操作"><span class="nav-number">5.</span> <span class="nav-text">get操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Node结点的查找"><span class="nav-number">5.1.</span> <span class="nav-text">Node结点的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeBin结点的查找"><span class="nav-number">5.2.</span> <span class="nav-text">TreeBin结点的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForwardingNode结点的查找"><span class="nav-number">5.3.</span> <span class="nav-text">ForwardingNode结点的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReservationNode结点的查找"><span class="nav-number">5.4.</span> <span class="nav-text">ReservationNode结点的查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈树义</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("ytt7fLFQUG3Iaddbl8u37qR4-gzGzoHsz", "CgXunVBQDWaT1EHkxf8FR0QP");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
